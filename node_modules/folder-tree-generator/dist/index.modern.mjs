#!/usr/bin/env node
import e from"chalk";import{program as r}from"commander";import*as o from"fs";import t from"update-notifier";import*as n from"path";var s="1.1.6";const i={line:"│   ",contain:"├── ",last:"└── "},l=(e,r,o=[],t=0,n)=>{const{line:s,contain:a,last:c}=i;for(const i in e){const p=i,f=e[p],y=Array.isArray(f),g="string"==typeof f,d=y,m=Array.isArray(e)&&[...e].pop(),h=!y&&m===f,u=y&&!f.length,x=(Array.isArray(n)&&[...n].pop())===e&&u,b=r.comments&&u&&!r.folderOnly?" # Empty folder":"",$=r.emojis?g?"📄 ":"📁 ":"",j=g?f:Array.isArray(e)?null:p;let E=Array.from({length:t},()=>s).join("");null!==j&&o.push(`${E}${(x||h)&&t?c:a}${$}${j}${b}`),"object"==typeof f&&l(f,r,o,d?t+1:t,e)}return o.join("\n")},a=(r,o={})=>{try{const e=p(r,o);return"object"==typeof e?l(e,o):e}catch(r){return void(r instanceof Error&&console.log(e.bgRed.bold(` ${r.message} `)))}},c=e=>{const r=[];return e.filter(e=>{if("object"==typeof e)return e[Object.keys(e)[0]]=c(e[Object.keys(e)[0]]),!0}).sort((e,r)=>{const o=Object.keys(e)[0],t=Object.keys(r)[0];return o<t?-1:o>t?1:0}).forEach(e=>r.push(e)),e.filter(e=>"string"==typeof e).sort().forEach(e=>r.push(e)),r},p=(r,t={})=>{var s;t.ignore=[".vscode",".DS_Store",".git","node_modules","dist","coverage",".husky",...t.ignore&&t.ignore||[]];const i=n.basename(r);if(!o.lstatSync(r).isDirectory())return i;let l=o.readdirSync(r);if(null!=(s=t.ignore)&&s.length){const r=t.ignore.map(r=>{try{return new RegExp(r)}catch(o){throw Error(` ✗ Incorrect Regexp: ${e.yellow(`'${r}'`)} `)}});l=l.filter(e=>r.every(r=>!r.test(`${e}`)))}const a=l.length?l.reduce((e,n)=>(e[i]=o.lstatSync(`${r}/${n}`).isDirectory()?[...e[i]||[],p(`${r}/${n}`,t)].filter(Boolean):e[i]=t.folderOnly?Array(...e[i]||[]):Array(...e[i]||[],n),e),{}):{[i]:[]};return t.sort&&(a[i]=c(a[i])),a},[,,...f]=process.argv;if(f.length){r.version(s).option("-d, --directory [dir]","Directory path",process.cwd()).option("-f, --folder-only","Draw folders only").option("-s, --sort","Sort alphabetically and put folders first and then files").option("-c, --comments",'Show "Empty folder" comment (--folder-only must be false)').option("-e, --export [path]",'Set the folder path to export "ftg_tree_[date].txt" or just -e or --export for the default export to the current path').option("-i, --ignore [regex]",'Regex list to ignore folders and/or files (separated by commas) - eg: "example($|/.*),index.ts"').option("--emojis","Show emojis - folder: 📁 - File: 📄").parse(process.argv);const n=r.opts();try{if(o.lstatSync(n.directory),n.ignore){if("string"!=typeof n.ignore)throw Error(e.bgRed.bold("✗ Missing regex list"));n.ignore=n.ignore.split(",").map(e=>e.trim())}const r=p(n.directory,n);if("object"==typeof r){const t=l(r,n);console.log(e.green("--- TREE FROM TERMINAL ---\n")),console.log(t),console.log(e.green("\n--------------------------")),n.export&&(n.export="string"!=typeof n.export?n.directory:n.export,o.writeFile(`${n.export}/ftg_tree_${(new Date).toISOString()}.txt`,t,r=>{if(r)throw Error;console.log(`\n ${e.green("FTG Tree has been exported into")} ${e.yellow(n.export)}`)}))}t({pkg:{name:"folder-tree-generator",version:s},shouldNotifyInNpmScript:!0,updateCheckInterval:0}).notify({isGlobal:!0})}catch(r){r instanceof Error&&console.log(e.bgRed.bold(` ${r.message} `))}}export{l as drawTreeFromJsonDir,a as ftg,p as parseDirToJson,c as sortFolder};
//# sourceMappingURL=index.modern.mjs.map
