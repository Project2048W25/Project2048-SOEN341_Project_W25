{"version":3,"file":"index.modern.mjs","sources":["../src/utils/drawTreeFromJsonDir.ts","../src/utils/ftg.ts","../src/utils/sortFolder.ts","../src/utils/parseDirToJson.ts","../src/bin/index.ts"],"sourcesContent":["import { FtgOptions } from './ftg'\nimport { DirData } from './parseDirToJson'\n\nconst treeSymbols = {\n\tline: '│   ',\n\tcontain: '├── ',\n\tlast: '└── ',\n}\n\n/**\n *\tDraw Tree from json dir\n * @param dirData\n * @param options\n * @param accumulator\n * @param level\n * @param parent\n * @returns\n */\nexport const drawTreeFromJsonDir = (\n\tdirData: DirData,\n\toptions: FtgOptions,\n\taccumulator: string[] = [],\n\tlevel = 0,\n\tparent?: DirData\n): string => {\n\tconst { line, contain, last } = treeSymbols\n\n\tfor (const key in dirData) {\n\t\tconst typedKey = key as keyof DirData\n\n\t\t// Current\n\t\tconst current = dirData[typedKey]\n\t\tconst currentIsArray = Array.isArray(current)\n\t\tconst currentIsFile = typeof current === 'string'\n\t\t// Level\n\t\tconst isNextLevel = currentIsArray\n\t\t// File\n\t\tconst lastItem = Array.isArray(dirData) && [...dirData].pop()\n\t\tconst isLastFile = !currentIsArray && lastItem === current\n\t\t// Folder\n\t\tconst isEmptyFolder = currentIsArray && !current.length\n\t\tconst lastFolderInParent = Array.isArray(parent) && [...parent].pop()\n\t\tconst isLastEmptyFolder = lastFolderInParent === dirData && isEmptyFolder\n\t\tconst emptyFolderComment =\n\t\t\toptions.comments && isEmptyFolder && !options.folderOnly\n\t\t\t\t? ' # Empty folder'\n\t\t\t\t: ''\n\n\t\tconst emojis = options.emojis ? (currentIsFile ? '📄 ' : '📁 ') : ''\n\n\t\tconst name = currentIsFile\n\t\t\t? current\n\t\t\t: !Array.isArray(dirData)\n\t\t\t? typedKey\n\t\t\t: null\n\n\t\tlet levelPrefix = Array.from({ length: level }, () => line).join('')\n\n\t\tconst delimiter =\n\t\t\t(isLastEmptyFolder || isLastFile) && level ? last : contain\n\n\t\tif (name !== null) {\n\t\t\taccumulator.push(\n\t\t\t\t`${levelPrefix}${delimiter}${emojis}${name}${emptyFolderComment}`\n\t\t\t)\n\t\t}\n\n\t\tif (typeof current === 'object') {\n\t\t\tdrawTreeFromJsonDir(\n\t\t\t\tcurrent,\n\t\t\t\toptions,\n\t\t\t\taccumulator,\n\t\t\t\tisNextLevel ? level + 1 : level,\n\t\t\t\tdirData\n\t\t\t)\n\t\t}\n\t}\n\treturn accumulator.join('\\n')\n}\n","import chalk from 'chalk'\nimport { drawTreeFromJsonDir, parseDirToJson } from '.'\n\nexport interface FtgOptions {\n\tfolderOnly?: boolean\n\tignore?: string[]\n\tsort?: boolean\n\tcomments?: boolean\n\temojis?: boolean\n}\n\n/**\n * Folder Tree Generator\n * @param path\n * @param options\n */\nexport const ftg = (\n\tpath: string,\n\toptions: FtgOptions = {}\n): string | undefined => {\n\ttry {\n\t\tconst jsonDir = parseDirToJson(path, options)\n\n\t\tif (typeof jsonDir === 'object') {\n\t\t\tconst tree = drawTreeFromJsonDir(jsonDir, options)\n\t\t\treturn tree\n\t\t}\n\n\t\treturn jsonDir\n\t} catch (error) {\n\t\tif (error instanceof Error) {\n\t\t\tconsole.log(chalk.bgRed.bold(` ${error.message} `))\n\t\t}\n\n\t\treturn\n\t}\n}\n","/**\n * Sort directory recursively\n * Rules:\n *  * Folders first\n *  * In alphabetical order\n * @param arr\n * @returns\n */\nexport const sortFolder = (arr: Array<string | Record<string, any>>) => {\n\tconst sorted: Array<string | Record<string, any>> = []\n\n\t// filter and sort folders by name\n\tarr\n\t\t.filter(item => {\n\t\t\tif (typeof item === 'object') {\n\t\t\t\titem[Object.keys(item)[0]] = sortFolder(item[Object.keys(item)[0]])\n\t\t\t\treturn true\n\t\t\t}\n\t\t})\n\t\t.sort((a, b) => {\n\t\t\tconst a1 = Object.keys(a)[0]\n\t\t\tconst b1 = Object.keys(b)[0]\n\t\t\treturn a1 < b1 ? -1 : a1 > b1 ? 1 : 0\n\t\t})\n\t\t.forEach(item => sorted.push(item))\n\n\t// Filter and sort files by name\n\tarr\n\t\t.filter(item => typeof item === 'string')\n\t\t.sort()\n\t\t.forEach(item => sorted.push(item))\n\n\treturn sorted\n}\n","import chalk from 'chalk'\nimport * as fs from 'fs'\nimport * as path from 'path'\nimport { FtgOptions } from './ftg'\nimport { sortFolder } from './sortFolder'\n\nexport type DirData = Record<string, any> | Array<string | Record<string, any>>\n\n/**\n * Parse directory to json from path\n * @param dirPath\n * @returns\n */\nexport const parseDirToJson = (\n\tdirPath: string,\n\toptions: FtgOptions = {}\n): DirData | string | undefined => {\n\tconst defaultIgnore = [\n\t\t'.vscode',\n\t\t'.DS_Store',\n\t\t'.git',\n\t\t'node_modules',\n\t\t'dist',\n\t\t'coverage',\n\t\t'.husky',\n\t]\n\n\toptions.ignore = [\n\t\t...defaultIgnore,\n\t\t...((options.ignore && options.ignore) || []),\n\t]\n\n\tconst baseName = path.basename(dirPath)\n\n\tif (!fs.lstatSync(dirPath).isDirectory()) {\n\t\treturn baseName\n\t}\n\n\tlet dirArrayString = fs.readdirSync(dirPath)\n\n\tif (options.ignore?.length) {\n\t\t// Ignore files and folders\n\t\tconst ignoreRegexpArray = options.ignore.map(item => {\n\t\t\ttry {\n\t\t\t\treturn new RegExp(item)\n\t\t\t} catch (error) {\n\t\t\t\tthrow Error(` ✗ Incorrect Regexp: ${chalk.yellow(`'${item}'`)} `)\n\t\t\t}\n\t\t})\n\t\tdirArrayString = dirArrayString.filter(value => {\n\t\t\treturn ignoreRegexpArray.every(regex => !regex.test(`${value}`))\n\t\t})\n\t}\n\n\tconst objDirectory = dirArrayString.length\n\t\t? dirArrayString.reduce((acc: Record<string, any>, curr) => {\n\t\t\t\tif (fs.lstatSync(`${dirPath}/${curr}`).isDirectory()) {\n\t\t\t\t\t//if curr is directory\n\t\t\t\t\tacc[baseName] = [\n\t\t\t\t\t\t...(acc[baseName] || []),\n\t\t\t\t\t\tparseDirToJson(`${dirPath}/${curr}`, options),\n\t\t\t\t\t].filter(Boolean)\n\t\t\t\t} else {\n\t\t\t\t\tif (!options.folderOnly) {\n\t\t\t\t\t\t// If curr is a file and is not in \"defaultIgnore\"\n\t\t\t\t\t\tacc[baseName] = acc[baseName] = Array<any>(\n\t\t\t\t\t\t\t...(acc[baseName] || []),\n\t\t\t\t\t\t\tcurr\n\t\t\t\t\t\t)\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// If curr is a file but only folders are included\n\t\t\t\t\t\t// This way the parent folder can be empty\n\t\t\t\t\t\tacc[baseName] = acc[baseName] = Array<any>(...(acc[baseName] || []))\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn acc\n\t\t  }, {})\n\t\t: { [baseName]: [] } // If the directory is empty\n\n\t// Sort Directory\n\tif (options.sort) {\n\t\tobjDirectory[baseName] = sortFolder(objDirectory[baseName])\n\t}\n\n\treturn objDirectory\n}\n","#!/usr/bin/env node\n\nimport chalk from 'chalk'\nimport { program } from 'commander'\nimport * as fs from 'fs'\nimport updateNotifier from 'update-notifier'\nimport { name, version } from '../../package.json'\nimport { drawTreeFromJsonDir, parseDirToJson } from '../utils'\n\nconst [, , ...args] = process.argv\nif (args.length) {\n\tprogram\n\t\t.version(version)\n\t\t.option('-d, --directory [dir]', 'Directory path', process.cwd())\n\t\t.option('-f, --folder-only', 'Draw folders only')\n\t\t.option(\n\t\t\t'-s, --sort',\n\t\t\t'Sort alphabetically and put folders first and then files'\n\t\t)\n\t\t.option(\n\t\t\t'-c, --comments',\n\t\t\t'Show \"Empty folder\" comment (--folder-only must be false)'\n\t\t)\n\t\t.option(\n\t\t\t'-e, --export [path]',\n\t\t\t'Set the folder path to export \"ftg_tree_[date].txt\" or just -e or --export for the default export to the current path'\n\t\t)\n\t\t.option(\n\t\t\t'-i, --ignore [regex]',\n\t\t\t'Regex list to ignore folders and/or files (separated by commas) - eg: \"example($|/.*),index.ts\"'\n\t\t)\n\t\t.option('--emojis', 'Show emojis - folder: 📁 - File: 📄')\n\t\t.parse(process.argv)\n\n\tconst options = program.opts()\n\n\ttry {\n\t\tfs.lstatSync(options.directory)\n\n\t\tif (options.ignore) {\n\t\t\tif (typeof options.ignore !== 'string') {\n\t\t\t\tthrow Error(chalk.bgRed.bold('✗ Missing regex list'))\n\t\t\t}\n\t\t\toptions.ignore = options.ignore.split(',').map(item => item.trim())\n\t\t}\n\n\t\tconst jsonDir = parseDirToJson(options.directory, options)\n\n\t\tif (typeof jsonDir === 'object') {\n\t\t\tconst tree = drawTreeFromJsonDir(jsonDir, options)\n\t\t\tconsole.log(chalk.green('--- TREE FROM TERMINAL ---\\n'))\n\t\t\tconsole.log(tree)\n\t\t\tconsole.log(chalk.green('\\n--------------------------'))\n\n\t\t\tif (options.export) {\n\t\t\t\toptions.export =\n\t\t\t\t\ttypeof options.export !== 'string'\n\t\t\t\t\t\t? options.directory\n\t\t\t\t\t\t: options.export\n\n\t\t\t\tfs.writeFile(\n\t\t\t\t\t`${options.export}/ftg_tree_${new Date().toISOString()}.txt`,\n\t\t\t\t\ttree,\n\t\t\t\t\terror => {\n\t\t\t\t\t\tif (error) {\n\t\t\t\t\t\t\tthrow Error\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconsole.log(\n\t\t\t\t\t\t\t`\\n ${chalk.green(\n\t\t\t\t\t\t\t\t'FTG Tree has been exported into'\n\t\t\t\t\t\t\t)} ${chalk.yellow(options.export)}`\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}\n\t\t}\n\t\t// Show available update\n\t\tupdateNotifier({\n\t\t\tpkg: { name, version },\n\t\t\tshouldNotifyInNpmScript: true,\n\t\t\tupdateCheckInterval: 0,\n\t\t}).notify({ isGlobal: true })\n\t} catch (error) {\n\t\tif (error instanceof Error) {\n\t\t\tconsole.log(chalk.bgRed.bold(` ${error.message} `))\n\t\t}\n\t}\n}\n"],"names":["treeSymbols","line","contain","last","drawTreeFromJsonDir","dirData","options","accumulator","level","parent","key","typedKey","current","currentIsArray","Array","isArray","currentIsFile","isNextLevel","lastItem","pop","isEmptyFolder","length","comments","folderOnly","emojis","name","levelPrefix","from","join","push","isLastEmptyFolder","isLastFile","emptyFolderComment","ftg","path","jsonDir","parseDirToJson","error","Error","console","log","chalk","bgRed","bold","message","sortFolder","arr","sorted","filter","item","Object","keys","sort","a","b","a1","b1","forEach","dirPath","ignore","baseName","basename","fs","lstatSync","isDirectory","dirArrayString","readdirSync","_options$ignore","ignoreRegexpArray","map","yellow","value","every","regex","test","objDirectory","reduce","acc","curr","Boolean","args","process","argv","program","version","option","cwd","parse","opts","directory","split","trim","tree","green","export","writeFile","toISOString","updateNotifier","pkg","shouldNotifyInNpmScript","updateCheckInterval","notify","isGlobal"],"mappings":"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"}