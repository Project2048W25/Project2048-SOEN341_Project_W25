{"version":3,"file":"index.mjs","sources":["../src/utils/drawTreeFromJsonDir.ts","../src/utils/ftg.ts","../src/utils/sortFolder.ts","../src/utils/parseDirToJson.ts","../src/bin/index.ts"],"sourcesContent":["import { FtgOptions } from './ftg'\nimport { DirData } from './parseDirToJson'\n\nconst treeSymbols = {\n\tline: '│   ',\n\tcontain: '├── ',\n\tlast: '└── ',\n}\n\n/**\n *\tDraw Tree from json dir\n * @param dirData\n * @param options\n * @param accumulator\n * @param level\n * @param parent\n * @returns\n */\nexport const drawTreeFromJsonDir = (\n\tdirData: DirData,\n\toptions: FtgOptions,\n\taccumulator: string[] = [],\n\tlevel = 0,\n\tparent?: DirData\n): string => {\n\tconst { line, contain, last } = treeSymbols\n\n\tfor (const key in dirData) {\n\t\tconst typedKey = key as keyof DirData\n\n\t\t// Current\n\t\tconst current = dirData[typedKey]\n\t\tconst currentIsArray = Array.isArray(current)\n\t\tconst currentIsFile = typeof current === 'string'\n\t\t// Level\n\t\tconst isNextLevel = currentIsArray\n\t\t// File\n\t\tconst lastItem = Array.isArray(dirData) && [...dirData].pop()\n\t\tconst isLastFile = !currentIsArray && lastItem === current\n\t\t// Folder\n\t\tconst isEmptyFolder = currentIsArray && !current.length\n\t\tconst lastFolderInParent = Array.isArray(parent) && [...parent].pop()\n\t\tconst isLastEmptyFolder = lastFolderInParent === dirData && isEmptyFolder\n\t\tconst emptyFolderComment =\n\t\t\toptions.comments && isEmptyFolder && !options.folderOnly\n\t\t\t\t? ' # Empty folder'\n\t\t\t\t: ''\n\n\t\tconst emojis = options.emojis ? (currentIsFile ? '📄 ' : '📁 ') : ''\n\n\t\tconst name = currentIsFile\n\t\t\t? current\n\t\t\t: !Array.isArray(dirData)\n\t\t\t? typedKey\n\t\t\t: null\n\n\t\tlet levelPrefix = Array.from({ length: level }, () => line).join('')\n\n\t\tconst delimiter =\n\t\t\t(isLastEmptyFolder || isLastFile) && level ? last : contain\n\n\t\tif (name !== null) {\n\t\t\taccumulator.push(\n\t\t\t\t`${levelPrefix}${delimiter}${emojis}${name}${emptyFolderComment}`\n\t\t\t)\n\t\t}\n\n\t\tif (typeof current === 'object') {\n\t\t\tdrawTreeFromJsonDir(\n\t\t\t\tcurrent,\n\t\t\t\toptions,\n\t\t\t\taccumulator,\n\t\t\t\tisNextLevel ? level + 1 : level,\n\t\t\t\tdirData\n\t\t\t)\n\t\t}\n\t}\n\treturn accumulator.join('\\n')\n}\n","import chalk from 'chalk'\nimport { drawTreeFromJsonDir, parseDirToJson } from '.'\n\nexport interface FtgOptions {\n\tfolderOnly?: boolean\n\tignore?: string[]\n\tsort?: boolean\n\tcomments?: boolean\n\temojis?: boolean\n}\n\n/**\n * Folder Tree Generator\n * @param path\n * @param options\n */\nexport const ftg = (\n\tpath: string,\n\toptions: FtgOptions = {}\n): string | undefined => {\n\ttry {\n\t\tconst jsonDir = parseDirToJson(path, options)\n\n\t\tif (typeof jsonDir === 'object') {\n\t\t\tconst tree = drawTreeFromJsonDir(jsonDir, options)\n\t\t\treturn tree\n\t\t}\n\n\t\treturn jsonDir\n\t} catch (error) {\n\t\tif (error instanceof Error) {\n\t\t\tconsole.log(chalk.bgRed.bold(` ${error.message} `))\n\t\t}\n\n\t\treturn\n\t}\n}\n","/**\n * Sort directory recursively\n * Rules:\n *  * Folders first\n *  * In alphabetical order\n * @param arr\n * @returns\n */\nexport const sortFolder = (arr: Array<string | Record<string, any>>) => {\n\tconst sorted: Array<string | Record<string, any>> = []\n\n\t// filter and sort folders by name\n\tarr\n\t\t.filter(item => {\n\t\t\tif (typeof item === 'object') {\n\t\t\t\titem[Object.keys(item)[0]] = sortFolder(item[Object.keys(item)[0]])\n\t\t\t\treturn true\n\t\t\t}\n\t\t})\n\t\t.sort((a, b) => {\n\t\t\tconst a1 = Object.keys(a)[0]\n\t\t\tconst b1 = Object.keys(b)[0]\n\t\t\treturn a1 < b1 ? -1 : a1 > b1 ? 1 : 0\n\t\t})\n\t\t.forEach(item => sorted.push(item))\n\n\t// Filter and sort files by name\n\tarr\n\t\t.filter(item => typeof item === 'string')\n\t\t.sort()\n\t\t.forEach(item => sorted.push(item))\n\n\treturn sorted\n}\n","import chalk from 'chalk'\nimport * as fs from 'fs'\nimport * as path from 'path'\nimport { FtgOptions } from './ftg'\nimport { sortFolder } from './sortFolder'\n\nexport type DirData = Record<string, any> | Array<string | Record<string, any>>\n\n/**\n * Parse directory to json from path\n * @param dirPath\n * @returns\n */\nexport const parseDirToJson = (\n\tdirPath: string,\n\toptions: FtgOptions = {}\n): DirData | string | undefined => {\n\tconst defaultIgnore = [\n\t\t'.vscode',\n\t\t'.DS_Store',\n\t\t'.git',\n\t\t'node_modules',\n\t\t'dist',\n\t\t'coverage',\n\t\t'.husky',\n\t]\n\n\toptions.ignore = [\n\t\t...defaultIgnore,\n\t\t...((options.ignore && options.ignore) || []),\n\t]\n\n\tconst baseName = path.basename(dirPath)\n\n\tif (!fs.lstatSync(dirPath).isDirectory()) {\n\t\treturn baseName\n\t}\n\n\tlet dirArrayString = fs.readdirSync(dirPath)\n\n\tif (options.ignore?.length) {\n\t\t// Ignore files and folders\n\t\tconst ignoreRegexpArray = options.ignore.map(item => {\n\t\t\ttry {\n\t\t\t\treturn new RegExp(item)\n\t\t\t} catch (error) {\n\t\t\t\tthrow Error(` ✗ Incorrect Regexp: ${chalk.yellow(`'${item}'`)} `)\n\t\t\t}\n\t\t})\n\t\tdirArrayString = dirArrayString.filter(value => {\n\t\t\treturn ignoreRegexpArray.every(regex => !regex.test(`${value}`))\n\t\t})\n\t}\n\n\tconst objDirectory = dirArrayString.length\n\t\t? dirArrayString.reduce((acc: Record<string, any>, curr) => {\n\t\t\t\tif (fs.lstatSync(`${dirPath}/${curr}`).isDirectory()) {\n\t\t\t\t\t//if curr is directory\n\t\t\t\t\tacc[baseName] = [\n\t\t\t\t\t\t...(acc[baseName] || []),\n\t\t\t\t\t\tparseDirToJson(`${dirPath}/${curr}`, options),\n\t\t\t\t\t].filter(Boolean)\n\t\t\t\t} else {\n\t\t\t\t\tif (!options.folderOnly) {\n\t\t\t\t\t\t// If curr is a file and is not in \"defaultIgnore\"\n\t\t\t\t\t\tacc[baseName] = acc[baseName] = Array<any>(\n\t\t\t\t\t\t\t...(acc[baseName] || []),\n\t\t\t\t\t\t\tcurr\n\t\t\t\t\t\t)\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// If curr is a file but only folders are included\n\t\t\t\t\t\t// This way the parent folder can be empty\n\t\t\t\t\t\tacc[baseName] = acc[baseName] = Array<any>(...(acc[baseName] || []))\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn acc\n\t\t  }, {})\n\t\t: { [baseName]: [] } // If the directory is empty\n\n\t// Sort Directory\n\tif (options.sort) {\n\t\tobjDirectory[baseName] = sortFolder(objDirectory[baseName])\n\t}\n\n\treturn objDirectory\n}\n","#!/usr/bin/env node\n\nimport chalk from 'chalk'\nimport { program } from 'commander'\nimport * as fs from 'fs'\nimport updateNotifier from 'update-notifier'\nimport { name, version } from '../../package.json'\nimport { drawTreeFromJsonDir, parseDirToJson } from '../utils'\n\nconst [, , ...args] = process.argv\nif (args.length) {\n\tprogram\n\t\t.version(version)\n\t\t.option('-d, --directory [dir]', 'Directory path', process.cwd())\n\t\t.option('-f, --folder-only', 'Draw folders only')\n\t\t.option(\n\t\t\t'-s, --sort',\n\t\t\t'Sort alphabetically and put folders first and then files'\n\t\t)\n\t\t.option(\n\t\t\t'-c, --comments',\n\t\t\t'Show \"Empty folder\" comment (--folder-only must be false)'\n\t\t)\n\t\t.option(\n\t\t\t'-e, --export [path]',\n\t\t\t'Set the folder path to export \"ftg_tree_[date].txt\" or just -e or --export for the default export to the current path'\n\t\t)\n\t\t.option(\n\t\t\t'-i, --ignore [regex]',\n\t\t\t'Regex list to ignore folders and/or files (separated by commas) - eg: \"example($|/.*),index.ts\"'\n\t\t)\n\t\t.option('--emojis', 'Show emojis - folder: 📁 - File: 📄')\n\t\t.parse(process.argv)\n\n\tconst options = program.opts()\n\n\ttry {\n\t\tfs.lstatSync(options.directory)\n\n\t\tif (options.ignore) {\n\t\t\tif (typeof options.ignore !== 'string') {\n\t\t\t\tthrow Error(chalk.bgRed.bold('✗ Missing regex list'))\n\t\t\t}\n\t\t\toptions.ignore = options.ignore.split(',').map(item => item.trim())\n\t\t}\n\n\t\tconst jsonDir = parseDirToJson(options.directory, options)\n\n\t\tif (typeof jsonDir === 'object') {\n\t\t\tconst tree = drawTreeFromJsonDir(jsonDir, options)\n\t\t\tconsole.log(chalk.green('--- TREE FROM TERMINAL ---\\n'))\n\t\t\tconsole.log(tree)\n\t\t\tconsole.log(chalk.green('\\n--------------------------'))\n\n\t\t\tif (options.export) {\n\t\t\t\toptions.export =\n\t\t\t\t\ttypeof options.export !== 'string'\n\t\t\t\t\t\t? options.directory\n\t\t\t\t\t\t: options.export\n\n\t\t\t\tfs.writeFile(\n\t\t\t\t\t`${options.export}/ftg_tree_${new Date().toISOString()}.txt`,\n\t\t\t\t\ttree,\n\t\t\t\t\terror => {\n\t\t\t\t\t\tif (error) {\n\t\t\t\t\t\t\tthrow Error\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconsole.log(\n\t\t\t\t\t\t\t`\\n ${chalk.green(\n\t\t\t\t\t\t\t\t'FTG Tree has been exported into'\n\t\t\t\t\t\t\t)} ${chalk.yellow(options.export)}`\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}\n\t\t}\n\t\t// Show available update\n\t\tupdateNotifier({\n\t\t\tpkg: { name, version },\n\t\t\tshouldNotifyInNpmScript: true,\n\t\t\tupdateCheckInterval: 0,\n\t\t}).notify({ isGlobal: true })\n\t} catch (error) {\n\t\tif (error instanceof Error) {\n\t\t\tconsole.log(chalk.bgRed.bold(` ${error.message} `))\n\t\t}\n\t}\n}\n"],"names":["drawTreeFromJsonDir","dirData","options","accumulator","level","parent","key","typedKey","current","currentIsArray","Array","isArray","currentIsFile","isNextLevel","lastItem","pop","isLastFile","isEmptyFolder","length","isLastEmptyFolder","emptyFolderComment","comments","folderOnly","emojis","name","from","join","push","levelPrefix","path","jsonDir","parseDirToJson","error","Error","console","log","chalk","bgRed","bold","message","sortFolder","arr","filter","item","Object","keys","sort","a","b","a1","b1","forEach","sorted","dirPath","ignore","concat","basename","fs","lstatSync","isDirectory","baseName","dirArrayString","readdirSync","_options$ignore","map","RegExp","yellow","value","ignoreRegexpArray","every","regex","test","reduce","acc","curr","Boolean","_ref","objDirectory","process","argv","program","version","option","cwd","parse","opts","directory","split","trim","tree","green","writeFile","Date","toISOString","updateNotifier","pkg","shouldNotifyInNpmScript","updateCheckInterval","notify","isGlobal"],"mappings":"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"}