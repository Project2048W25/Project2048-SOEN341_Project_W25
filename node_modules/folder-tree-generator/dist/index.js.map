{"version":3,"file":"index.js","sources":["../src/utils/drawTreeFromJsonDir.ts","../src/utils/sortFolder.ts","../src/utils/parseDirToJson.ts","../src/bin/index.ts","../src/utils/ftg.ts"],"sourcesContent":["import { FtgOptions } from './ftg'\nimport { DirData } from './parseDirToJson'\n\nconst treeSymbols = {\n\tline: '│   ',\n\tcontain: '├── ',\n\tlast: '└── ',\n}\n\n/**\n *\tDraw Tree from json dir\n * @param dirData\n * @param options\n * @param accumulator\n * @param level\n * @param parent\n * @returns\n */\nexport const drawTreeFromJsonDir = (\n\tdirData: DirData,\n\toptions: FtgOptions,\n\taccumulator: string[] = [],\n\tlevel = 0,\n\tparent?: DirData\n): string => {\n\tconst { line, contain, last } = treeSymbols\n\n\tfor (const key in dirData) {\n\t\tconst typedKey = key as keyof DirData\n\n\t\t// Current\n\t\tconst current = dirData[typedKey]\n\t\tconst currentIsArray = Array.isArray(current)\n\t\tconst currentIsFile = typeof current === 'string'\n\t\t// Level\n\t\tconst isNextLevel = currentIsArray\n\t\t// File\n\t\tconst lastItem = Array.isArray(dirData) && [...dirData].pop()\n\t\tconst isLastFile = !currentIsArray && lastItem === current\n\t\t// Folder\n\t\tconst isEmptyFolder = currentIsArray && !current.length\n\t\tconst lastFolderInParent = Array.isArray(parent) && [...parent].pop()\n\t\tconst isLastEmptyFolder = lastFolderInParent === dirData && isEmptyFolder\n\t\tconst emptyFolderComment =\n\t\t\toptions.comments && isEmptyFolder && !options.folderOnly\n\t\t\t\t? ' # Empty folder'\n\t\t\t\t: ''\n\n\t\tconst emojis = options.emojis ? (currentIsFile ? '📄 ' : '📁 ') : ''\n\n\t\tconst name = currentIsFile\n\t\t\t? current\n\t\t\t: !Array.isArray(dirData)\n\t\t\t? typedKey\n\t\t\t: null\n\n\t\tlet levelPrefix = Array.from({ length: level }, () => line).join('')\n\n\t\tconst delimiter =\n\t\t\t(isLastEmptyFolder || isLastFile) && level ? last : contain\n\n\t\tif (name !== null) {\n\t\t\taccumulator.push(\n\t\t\t\t`${levelPrefix}${delimiter}${emojis}${name}${emptyFolderComment}`\n\t\t\t)\n\t\t}\n\n\t\tif (typeof current === 'object') {\n\t\t\tdrawTreeFromJsonDir(\n\t\t\t\tcurrent,\n\t\t\t\toptions,\n\t\t\t\taccumulator,\n\t\t\t\tisNextLevel ? level + 1 : level,\n\t\t\t\tdirData\n\t\t\t)\n\t\t}\n\t}\n\treturn accumulator.join('\\n')\n}\n","/**\n * Sort directory recursively\n * Rules:\n *  * Folders first\n *  * In alphabetical order\n * @param arr\n * @returns\n */\nexport const sortFolder = (arr: Array<string | Record<string, any>>) => {\n\tconst sorted: Array<string | Record<string, any>> = []\n\n\t// filter and sort folders by name\n\tarr\n\t\t.filter(item => {\n\t\t\tif (typeof item === 'object') {\n\t\t\t\titem[Object.keys(item)[0]] = sortFolder(item[Object.keys(item)[0]])\n\t\t\t\treturn true\n\t\t\t}\n\t\t})\n\t\t.sort((a, b) => {\n\t\t\tconst a1 = Object.keys(a)[0]\n\t\t\tconst b1 = Object.keys(b)[0]\n\t\t\treturn a1 < b1 ? -1 : a1 > b1 ? 1 : 0\n\t\t})\n\t\t.forEach(item => sorted.push(item))\n\n\t// Filter and sort files by name\n\tarr\n\t\t.filter(item => typeof item === 'string')\n\t\t.sort()\n\t\t.forEach(item => sorted.push(item))\n\n\treturn sorted\n}\n","import chalk from 'chalk'\nimport * as fs from 'fs'\nimport * as path from 'path'\nimport { FtgOptions } from './ftg'\nimport { sortFolder } from './sortFolder'\n\nexport type DirData = Record<string, any> | Array<string | Record<string, any>>\n\n/**\n * Parse directory to json from path\n * @param dirPath\n * @returns\n */\nexport const parseDirToJson = (\n\tdirPath: string,\n\toptions: FtgOptions = {}\n): DirData | string | undefined => {\n\tconst defaultIgnore = [\n\t\t'.vscode',\n\t\t'.DS_Store',\n\t\t'.git',\n\t\t'node_modules',\n\t\t'dist',\n\t\t'coverage',\n\t\t'.husky',\n\t]\n\n\toptions.ignore = [\n\t\t...defaultIgnore,\n\t\t...((options.ignore && options.ignore) || []),\n\t]\n\n\tconst baseName = path.basename(dirPath)\n\n\tif (!fs.lstatSync(dirPath).isDirectory()) {\n\t\treturn baseName\n\t}\n\n\tlet dirArrayString = fs.readdirSync(dirPath)\n\n\tif (options.ignore?.length) {\n\t\t// Ignore files and folders\n\t\tconst ignoreRegexpArray = options.ignore.map(item => {\n\t\t\ttry {\n\t\t\t\treturn new RegExp(item)\n\t\t\t} catch (error) {\n\t\t\t\tthrow Error(` ✗ Incorrect Regexp: ${chalk.yellow(`'${item}'`)} `)\n\t\t\t}\n\t\t})\n\t\tdirArrayString = dirArrayString.filter(value => {\n\t\t\treturn ignoreRegexpArray.every(regex => !regex.test(`${value}`))\n\t\t})\n\t}\n\n\tconst objDirectory = dirArrayString.length\n\t\t? dirArrayString.reduce((acc: Record<string, any>, curr) => {\n\t\t\t\tif (fs.lstatSync(`${dirPath}/${curr}`).isDirectory()) {\n\t\t\t\t\t//if curr is directory\n\t\t\t\t\tacc[baseName] = [\n\t\t\t\t\t\t...(acc[baseName] || []),\n\t\t\t\t\t\tparseDirToJson(`${dirPath}/${curr}`, options),\n\t\t\t\t\t].filter(Boolean)\n\t\t\t\t} else {\n\t\t\t\t\tif (!options.folderOnly) {\n\t\t\t\t\t\t// If curr is a file and is not in \"defaultIgnore\"\n\t\t\t\t\t\tacc[baseName] = acc[baseName] = Array<any>(\n\t\t\t\t\t\t\t...(acc[baseName] || []),\n\t\t\t\t\t\t\tcurr\n\t\t\t\t\t\t)\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// If curr is a file but only folders are included\n\t\t\t\t\t\t// This way the parent folder can be empty\n\t\t\t\t\t\tacc[baseName] = acc[baseName] = Array<any>(...(acc[baseName] || []))\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn acc\n\t\t  }, {})\n\t\t: { [baseName]: [] } // If the directory is empty\n\n\t// Sort Directory\n\tif (options.sort) {\n\t\tobjDirectory[baseName] = sortFolder(objDirectory[baseName])\n\t}\n\n\treturn objDirectory\n}\n","#!/usr/bin/env node\n\nimport chalk from 'chalk'\nimport { program } from 'commander'\nimport * as fs from 'fs'\nimport updateNotifier from 'update-notifier'\nimport { name, version } from '../../package.json'\nimport { drawTreeFromJsonDir, parseDirToJson } from '../utils'\n\nconst [, , ...args] = process.argv\nif (args.length) {\n\tprogram\n\t\t.version(version)\n\t\t.option('-d, --directory [dir]', 'Directory path', process.cwd())\n\t\t.option('-f, --folder-only', 'Draw folders only')\n\t\t.option(\n\t\t\t'-s, --sort',\n\t\t\t'Sort alphabetically and put folders first and then files'\n\t\t)\n\t\t.option(\n\t\t\t'-c, --comments',\n\t\t\t'Show \"Empty folder\" comment (--folder-only must be false)'\n\t\t)\n\t\t.option(\n\t\t\t'-e, --export [path]',\n\t\t\t'Set the folder path to export \"ftg_tree_[date].txt\" or just -e or --export for the default export to the current path'\n\t\t)\n\t\t.option(\n\t\t\t'-i, --ignore [regex]',\n\t\t\t'Regex list to ignore folders and/or files (separated by commas) - eg: \"example($|/.*),index.ts\"'\n\t\t)\n\t\t.option('--emojis', 'Show emojis - folder: 📁 - File: 📄')\n\t\t.parse(process.argv)\n\n\tconst options = program.opts()\n\n\ttry {\n\t\tfs.lstatSync(options.directory)\n\n\t\tif (options.ignore) {\n\t\t\tif (typeof options.ignore !== 'string') {\n\t\t\t\tthrow Error(chalk.bgRed.bold('✗ Missing regex list'))\n\t\t\t}\n\t\t\toptions.ignore = options.ignore.split(',').map(item => item.trim())\n\t\t}\n\n\t\tconst jsonDir = parseDirToJson(options.directory, options)\n\n\t\tif (typeof jsonDir === 'object') {\n\t\t\tconst tree = drawTreeFromJsonDir(jsonDir, options)\n\t\t\tconsole.log(chalk.green('--- TREE FROM TERMINAL ---\\n'))\n\t\t\tconsole.log(tree)\n\t\t\tconsole.log(chalk.green('\\n--------------------------'))\n\n\t\t\tif (options.export) {\n\t\t\t\toptions.export =\n\t\t\t\t\ttypeof options.export !== 'string'\n\t\t\t\t\t\t? options.directory\n\t\t\t\t\t\t: options.export\n\n\t\t\t\tfs.writeFile(\n\t\t\t\t\t`${options.export}/ftg_tree_${new Date().toISOString()}.txt`,\n\t\t\t\t\ttree,\n\t\t\t\t\terror => {\n\t\t\t\t\t\tif (error) {\n\t\t\t\t\t\t\tthrow Error\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconsole.log(\n\t\t\t\t\t\t\t`\\n ${chalk.green(\n\t\t\t\t\t\t\t\t'FTG Tree has been exported into'\n\t\t\t\t\t\t\t)} ${chalk.yellow(options.export)}`\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}\n\t\t}\n\t\t// Show available update\n\t\tupdateNotifier({\n\t\t\tpkg: { name, version },\n\t\t\tshouldNotifyInNpmScript: true,\n\t\t\tupdateCheckInterval: 0,\n\t\t}).notify({ isGlobal: true })\n\t} catch (error) {\n\t\tif (error instanceof Error) {\n\t\t\tconsole.log(chalk.bgRed.bold(` ${error.message} `))\n\t\t}\n\t}\n}\n","import chalk from 'chalk'\nimport { drawTreeFromJsonDir, parseDirToJson } from '.'\n\nexport interface FtgOptions {\n\tfolderOnly?: boolean\n\tignore?: string[]\n\tsort?: boolean\n\tcomments?: boolean\n\temojis?: boolean\n}\n\n/**\n * Folder Tree Generator\n * @param path\n * @param options\n */\nexport const ftg = (\n\tpath: string,\n\toptions: FtgOptions = {}\n): string | undefined => {\n\ttry {\n\t\tconst jsonDir = parseDirToJson(path, options)\n\n\t\tif (typeof jsonDir === 'object') {\n\t\t\tconst tree = drawTreeFromJsonDir(jsonDir, options)\n\t\t\treturn tree\n\t\t}\n\n\t\treturn jsonDir\n\t} catch (error) {\n\t\tif (error instanceof Error) {\n\t\t\tconsole.log(chalk.bgRed.bold(` ${error.message} `))\n\t\t}\n\n\t\treturn\n\t}\n}\n"],"names":["drawTreeFromJsonDir","dirData","options","accumulator","level","parent","key","typedKey","current","currentIsArray","Array","isArray","currentIsFile","isNextLevel","lastItem","pop","isLastFile","isEmptyFolder","length","isLastEmptyFolder","emptyFolderComment","comments","folderOnly","emojis","name","from","join","push","levelPrefix","sortFolder","arr","filter","item","Object","keys","sort","a","b","a1","b1","forEach","sorted","parseDirToJson","dirPath","ignore","concat","path","basename","fs","lstatSync","isDirectory","baseName","dirArrayString","readdirSync","_options$ignore","map","RegExp","error","chalk","yellow","value","ignoreRegexpArray","every","regex","test","reduce","acc","curr","Boolean","_ref","objDirectory","process","argv","program","version","option","cwd","parse","opts","directory","Error","bgRed","bold","split","trim","jsonDir","tree","console","log","green","writeFile","Date","toISOString","updateNotifier","pkg","shouldNotifyInNpmScript","updateCheckInterval","notify","isGlobal","message"],"mappings":"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"}